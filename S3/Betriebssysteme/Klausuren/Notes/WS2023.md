# Aufgabe 1
>Zeichnen Sie ein Blockschaltbild einer einfachen Von-Neumann-Rechnerarchitektur bestehend aus CPU, Hauptspeicher, Massenspeicher und Bussystemen. Benennen Sie alle Komponenten. Erklären Sie Memory-Mapped Files.

![[assets/Pasted image 20240316180708.png]]
![[von-neumann.bSXLkpZL.jpg]]

# Aufgabe 2
>Betriebssysteme steuern und verwalten Betriebsmittel. Nennen Sie drei Betriebsmittel.

- Prozessor
- Speicher
- Threads
- Bildschirm
- Drucker
- ?!?!?!

# Aufgabe 3
>Zeichnen Sie das Prozesszustandsdiagramm von UNIX. Welcher Zustand ist besonders auffällig? Erklären Sie Sinn und Zweck dieses auffälligen Zustands.

![[Pasted image 20250113125220.png]]
Ein Zombie-Prozess ist ein Prozess in Unix-ähnlichen Betriebssystemen, der beendet wurde, aber dessen Exit-Status noch nicht vom übergeordneten Prozess abgeholt wurde. Der Zombie-Prozess nimmt noch Systemressourcen in Anspruch, aber er führt keine Aktivitäten mehr aus, da er bereits beendet wurde.

Zweck?

# Aufgabe 4
>In einem Rechenzentrum sind 2 Tapes, 2 Plotter, 2 Drucker und 1 3D-Drucker zur gemeinsamen Nutzung freigegeben: E = (2 2 2 1). Es gebe 5 Benutzerprozesse, die bereits Ressourcen nutzen und auch noch weitere Ressourcen belegen wollen. Führen Sie den aus der Vorlesung bekannten Algorithmus zur Verklemmungserkennung durch.

>Die Belegungsmatrix B und die Wünschematrix C sind wie folgt:

$$\begin{align*}
B=\begin{pmatrix}0 & 1&1&0 \\ 1&0&0&0 \\ 0&0&0&0 \\ 1&1&0&0 \\ 0&0&1&0\end{pmatrix} & & C=\begin{pmatrix}1&0&0&0\\
0&1&0&0\\
0&0&0&1\\
0&0&0&1\\
1&0&0&0\end{pmatrix}
\end{align*}$$

| **B** | Tapes | Plotter | Drucker | 3D-Drucker |
| ----- | ----- | ------- | ------- | ---------- |
| P1    | 0     | 1       | 1       | 0          |
| P2    | 1     | 0       | 0       | 0          |
| P3    | 0     | 0       | 0       | 0          |
| P4    | 1     | 1       | 0       | 0          |
| P5    | 0     | 0       | 1       | 0          |

| **B** | 2   | 2   | 2   | 0   |
| ----- | --- | --- | --- | --- |

| **E** | 2   | 2   | 2   | 1   |
| ----- | --- | --- | --- | --- |

| **E - B -> A** | 0   | 0   | 0   | 1   |
| -------------- | --- | --- | --- | --- |

Jetzt die Rechnungen:

| A     | 0   | 0   | 0   | 1   |
| ----- | --- | --- | --- | --- |
| C(P4) | 0   | 0   | 0   | 1   |
| B4    | 1   | 1   | 0   | 0   |

| A     | 1   | 1   | 0   | 1   |
| ----- | --- | --- | --- | --- |
| C(P3) | 0   | 0   | 0   | 1   |
| B3    | 0   | 0   | 0   | 0   |

| A     | 1   | 1   | 0   | 1   |
| ----- | --- | --- | --- | --- |
| C(P5) | 1   | 0   | 0   | 0   |
| B5    | 0   | 0   | 1   | 0   |

| A     | 1   | 1   | 1   | 1   |
| ----- | --- | --- | --- | --- |
| C(P2) | 0   | 1   | 0   | 0   |
| B2    | 1   | 0   | 0   | 0   |

| A     | 2   | 1   | 1   | 1   |
| ----- | --- | --- | --- | --- |
| C(P1) | 1   | 0   | 0   | 0   |
| B1    | 0   | 1   | 1   | 0   |

| **->A** | 2   | 2   | 2   | 1   |
| ------- | --- | --- | --- | --- |
**-> Keine Verklemmung**

# Aufgabe 4
>Wir hatten uns u.a. die Verfahren „First Fit“ und „Worst Fit“ für die Zuordnung von Hauptspeicher an Prozesse angesehen. Erklären Sie diese Verfahren. Zeichnen Sie die Ergebnisse beider Verfahren direkt in die u.a. Grafiken (jeweils ab der 2ten Zeile) für Start A: 18; Start B: 4; Start C: 4; Ende B; Start D: 5; Start E: 12 ein. Hinweis: Die z.Z. bereits belegten Speicherblöcke haben alle die Größe 1 (graue Felder).

**First Fit**
Erklärung

|             | 10    | 4   | 20  | 18  | 7   | 9   | 12  | 5   |
| ----------- | ----- | --- | --- | --- | --- | --- | --- | --- |
| Start A: 18 |       |     | A   |     |     |     |     |     |
| Start B: 4  | B     |     | A   |     |     |     |     |     |
| Start C: 4  | B + C |     | A   |     |     |     |     |     |
| Ende B      | C     |     | A   |     |     |     |     |     |
| Start D: 5  | C + D |     | A   |     |     |     |     |     |
| Start E: 12 | C + D |     | A   | E   |     |     |     |     |

**Worst Fit**
Erklärung

| Ereignis    | 10  | 4   | 20  | 18    | 7   | 9   | 12  | 5   |
| ----------- | --- | --- | --- | ----- | --- | --- | --- | --- |
| Start A: 18 |     |     | A   |       |     |     |     |     |
| Start B: 4  |     |     | A   | B + C |     |     |     |     |
| Start C: 4  |     |     | A   | B + C |     |     |     |     |
| Ende B      |     |     | A   | C     |     |     |     |     |
| Start D: 5  |     |     | A   | C + D |     |     |     |     |
| Start E: 12 |     |     | A   | C + D |     |     | E   |     |

# Aufgabe 6
>Führen Sie die Berechnungen für das Buddy-System mit folgenden Ereignissen durch: Start A: 212; Start B: 99; Start C: 62; Ende A; Start D: 128; Start E: 120; Ende B; Ende E; Start F: 256.

| Ereignis     | 512                               |
| ------------ | --------------------------------- |
| Start A: 212 | 256(A), 256                       |
| Start B: 99  | 256(A), 128(B), 128               |
| Start C: 62  | 256(A), 128(B), 64(C), 64         |
| Ende A       | 256, 128(B), 64(C), 64            |
| Start D: 128 | 128(D), 128, 128(B), 64(C), 64    |
| Start E: 120 | 128(D), 128(E), 128(B), 64(C), 64 |
| Ende B       | 128(D), 128(E), 128, 64(C), 64    |
| Ende E       | 128(D), 256, 64(C), 64            |
| Start F: 256 | 128(D), 256(F), 64(C), 64         |

# Aufgabe 7 (Chat GPT)
>**(a)** Betrachten wir 2stufiges paging für 32 Bit Speicheradresssen mit einem Offset von 12 Bit und jeweils 10 Bit für Seitenadressen pro Stufe. Zeichnen Sie alle benötigten Seitentabellen und Seiten inklusive der Verweise für einen kleinen Prozess, der 5.000 zusammenhängende Wörter belegt. Nutzen Sie ggfs. sinnvolle Abkürzungen wie "...". 
#### Gegeben:

- **32-Bit Speicheradresse**
    - **12-Bit Offset** → Größe jeder Seite = 2122^{12}212 Bytes = **4 KiB**
    - **10-Bit pro Stufe** → Jeweils 210=1,0242^{10} = 1,024210=1,024 Einträge pro Seitentabelle.
- **Prozessgröße**: 5,000 Wörter → 5,000×45,000 \times 45,000×4 Bytes/Wort = **20 KiB**.

#### Zerlegung der Adresse:

1. **12 Bit**: Offset innerhalb der Seite.
2. **10 Bit (Stufe 1)**: Index in der ersten Seitentabelle.
3. **10 Bit (Stufe 2)**: Index in der zweiten Seitentabelle.

#### Anzahl benötigter Seiten:

- Seitenanzahl=⌈Prozessgro¨ße/Seitengro¨ße⌉=⌈20 KiB/4 KiB⌉=5\text{Seitenanzahl} = \lceil \text{Prozessgröße} / \text{Seitengröße} \rceil = \lceil 20 \text{ KiB} / 4 \text{ KiB} \rceil = 5Seitenanzahl=⌈Prozessgro¨ße/Seitengro¨ße⌉=⌈20 KiB/4 KiB⌉=5 Seiten.

#### Aufbau der Tabellen:

1. **Erste Stufe (Level-1-Table)**:
    
    - Enthält Verweise auf die **zweite Stufe (Level-2-Tables)**.
    - Jede zweite Stufe hat bis zu 1,024 Einträge.
2. **Zweite Stufe (Level-2-Tables)**:
    
    - Verweist auf die **physikalischen Seiten im Speicher**.

##### Zeichnung der Tabellen (schematisch):
```
Level-1-Tabelle (10 Bit):
  [0] --> Level-2-Tabelle 0
  [1] --> ...
  [2] --> ...
  ...
  [N] --> ...

Level-2-Tabelle 0:
  [0] --> Phys. Seite 0
  [1] --> Phys. Seite 1
  [2] --> Phys. Seite 2
  [3] --> Phys. Seite 3
  [4] --> Phys. Seite 4
  ...

Prozess belegt Seiten:
- Phys. Seite 0, Phys. Seite 1, Phys. Seite 2, Phys. Seite 3, Phys. Seite 4.
```

>**(b)** Wieviel Speicherplatz wird für die Tabellen benötigt und wieviel Speicherplatz für den Prozess auf seinen Seiten? 
#### Speicherplatz für Tabellen:

- **Level-1-Tabelle**:  
    $2^{10}=1,024$ Einträge.  
    Jeder Eintrag benötigt 4 Bytes → Speicherplatz:  
    $1,024×4=4$ KiB.
    
- **Level-2-Tabelle(n)**:  
    Für 5 Seiten benötigt der Prozess **1 Level-2-Tabelle** (jede Level-2-Tabelle hat 1,024 Einträge).  
    Speicherplatz:  
    $1,024×4=4 KiB.$
    

**Gesamt für Tabellen:**  
$4 \text{ KiB (Level-1)} + 4 \text{ KiB (Level-2)} = 8 \text{ KiB}$

#### Speicherplatz für den Prozess:

- Der Prozess belegt 5 Seiten zu je 4 KiB.  
    Speicherplatz: $5 \times 4 \text{ KiB} = 20 \text{ KiB}$

**Gesamtbedarf:**  
$8 \text{ KiB (Tabellen)} + 20 \text{ KiB (Prozess)} = 28 \text{ KiB}$

>**(c)** Was ist der Hauptvorteil einer zweistufigen Seitentabelle gegenüber einer einstufigen Seitentabelle bei 32 Bit Wortbreite? 

Der Hauptvorteil liegt in der **Reduktion des Speicherplatzbedarfs für Seitentabellen** bei Prozessen, die nur einen kleinen Teil des Adressraums nutzen.

- Bei einer einstufigen Tabelle wäre der Platzbedarf für Seitentabellen immer: $2^{20}\text{ Einträge} \times 4 \text{ Bytes} = 4 \text{ MiB}$
- Mit einer zweistufigen Tabelle werden nur die tatsächlich genutzten Tabellenebenen angelegt. Im obigen Beispiel benötigt der Prozess nur **8 KiB** für Tabellen.

# Aufgabe 8
>Zeichnen Sie die Page Faults 
>- *Quadrate (no idea what that means - maybe neue Einfügungen, wodurch aber nichts ausm RAM fliegt?!)*, 
>- **Kreise (Etwas komplett neues (oder von der Disk) wird geladen, wodurch etwas ausm RAM fliegt)** 
>sowie die Seitenzahlen der Referenzfolge 0, 1, 40, 31, 30, 1, 0, 1, 0, 400, 30, 3, 31, 1, 30, ... in die Vorlagen ein.

**Optimale Stategie**

| RAM  | 0   | 1   | 40  | **31** | 1   | 0   | 1   | 0   | **400** | **30** | **3** | 31  | 1   | **30** | ... |
| ---- | --- | --- | --- | ------ | --- | --- | --- | --- | ------- | ------ | ----- | --- | --- | ------ | --- |
| RAM  |     | 0   | 1   | 1      | 31  | 1   | 0   | 1   | 1       | 1      | 1     | 3   | 31  | 1      |     |
| RAM  |     |     | 0   | 0      | 0   | 31  | 31  | 31  | 31      | 31     | 31    | 1   | 3   | 31     |     |
| Disk |     |     |     | 40     | 40  | 40  | 40  | 40  | 0       | 400    | 30    | 30  | 30  | 3      |     |
| Disk |     |     |     |        |     |     |     |     | 40      | 0      | 400   | 400 | 400 | 400    |     |
| Disk |     |     |     |        |     |     |     |     |         | 40     | 0     | 0   | 0   | 0      |     |
| Disk |     |     |     |        |     |     |     |     |         |        | 40    | 40  | 40  | 40     |     |
**FiFo (upsi war nicht gefragt)**

| RAM  | 0   | 1   | 40  | **31** | 1   | **0** | 1   | 0   | **400** | **30** | **3** | **31** | **1** | **30** | ... |
| ---- | --- | --- | --- | ------ | --- | ----- | --- | --- | ------- | ------ | ----- | ------ | ----- | ------ | --- |
| RAM  |     | 0   | 1   | 40     | 31  | 1     | 0   | 1   | 0       | 400    | 30    | 3      | 31    | 1      |     |
| RAM  |     |     | 0   | 1      | 40  | 31    | 31  | 31  | 1       | 0      | 400   | 30     | 3     | 31     |     |
| Disk |     |     |     | 0      | 0   | 40    | 40  | 40  | 31      | 1      | 0     | 400    | 30    | 3      |     |
| Disk |     |     |     |        |     |       |     |     | 40      | 31     | 1     | 0      | 400   | 400    |     |
| Disk |     |     |     |        |     |       |     |     |         | 40     | 31    | 1      | 0     | 0      |     |
| Disk |     |     |     |        |     |       |     |     |         |        | 40    | 40     | 40    | 40     |     |
**FiFo Second Chance (huh?)**

| RAM  | 0   | 1   | 40  | 31  | 1   | 0   | 1   | 0   | 400 | 30  | 3   | 31  | 1   | 30  | ... |
| ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| RAM  |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |
| RAM  |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |
| Disk |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |
| Disk |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |
| Disk |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |
| Disk |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |
